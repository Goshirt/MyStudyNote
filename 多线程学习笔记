
      https://juejin.im/post/5ba133126fb9a05ce02a6f12
      https://www.cnblogs.com/dolphin0520/p/3932921.html  线程池讲解
      不可指令重排的原则：
      1、	程序顺序原则：一个线程内保证语义的串行性。
      2、	volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性。
      3、	锁规则：解锁必先发生于在随后的加锁前。
      4、	传递性：A先于B，B先于C,则A必然先于C。
      5、	线程的start方法必先于他的每一个动作。
      6、	线程的所有操作都先于线程的终结。
      7、	线程的中断先于被中断线程的代码。
      8、	对象的构造函数执行，结束先于finalize()方法。


      线程Thread
      start()开始执行一个线程
      stop() 强行终止线程，即使当时线程还没有完成工作
      interrupt() 通知目标线程中断，并置上中断标注
      isInterrupted() 判断当前线程是否被中断，通过检查中断标记
      interrupted()判断当前线程是否被中断,同时清除中断标记
      join()等待线程结束和yield()谦让，join()一直阻塞当前线程，直到调用join()的线程执行结束，yield()让出当前的CPU，但是让出后还是会进行CPU的争夺

      Object类
      wait()等待与notify()通知，必须包含在synchronized语句中，因为必须现获得目标对象的监视器
      object.wait() 使得当前线程在该object对象上进行等待并释放该对象的监视器，直到其他线程调用该对象的object.notify()方法，notify()随机唤醒一个在此object对象上等待的线程

      volatile: 确保线程间的原子性、可见性、和原子性。但并不能保证线程的安全，两个线程同时修改某一个数据时，依然会发生冲突。

      线程组ThreadGroup()
      ThreadGround tg=new ThreadGround(“PrintGround”);   //创建一个名为PrintGround的线程组
      tg.activeCount();   //获取活动线程总数，由于线程是动态的，这个数只是一个估计值
      tg.list();   //打印线程组中所有线程的信息
      tg.stop()   //停止线程组中的所有线程

      Daemon() 守护线程：是一种特殊的线程，在后台默默的完成一些系统性的服务
      Thread td=new Thread();
      Td.setDaemon(true); //把线程设置为守护线程，必须在该线程start前设置，不然会报错。

      Synchronized ：对同步的代码加锁
      用法：
      1、	指定加锁对象：对给定的对象加锁，进入同步代码块前要获得给定的对象的锁
      2、	直接作用于实例方法：相当于对当前实例加锁，进入同步代码块前要获得当前实例的锁。
      3、	直接作用于静态方法：相当于对当前类加锁，进入同步代码块前要获得当前类的锁。
      当使用第一第二种方法加锁时，一定要确保多个线程指向的是同一个实例，确保是同一个对象锁，从而保证线程安全。

      ReentrantLock重入锁 :有着显示的加锁解锁过程
      ReentrantLock lock=new ReentrantLock();
      lock.lock();  //加锁
      lock.unlock();  //解锁
      lock.lockInterruptibly();  //可以相应中断的加锁，当线程被中断时，会放弃对锁的请求
      lock.tryLock(5,TimeUnit,SECONDS);  //限时等待获取锁，如果超过设置时间，会放弃获取锁。不带参数时，尝试获取锁，成功返回true,失败返回false.

      公平锁：表示锁是公平的，但是实现公平锁会要求系统维护一个有序队列，成本高，性能低下
      ReentrantLock lock=new ReentrantLock(true);  //当参数为true时，该锁为公平锁，默认为false

      Integer属于不可变对象，一旦被创建就不能被修改，如果重新赋值改变，其实是新建了一个Integer对象。

      避免死锁：
      1、获取锁的方式可以响应外部中断。
      2、获取锁的方式为限时等待。

   
   
   线程的状态
    （1）new：一个创建而未启动的线程处于该状态
    （2）Runable:包含两个子状态Ready和Running,前者表示处于该状态下的线程可以被线程调度器进行调度，后者表示线程正在运行。Ready状态被线程调度器调度后变成Running状态，执行Thread.yield(),有可能导致Running状态转换为Ready状态。
     (3) Blocked:当一个线程发起一个阻塞IO操作，或者申请一个其他线程持有的独占资源时，处于该状态。在该状态下不占用CPU资源，当阻塞IO操作完成后，或者获得了其申请的资源，该线程状态可以转换为Runnable.
     (4) Waiting:一个线程执行某些特定方法之后会处于这种等待其他线程执行另外的特定操作。Object.wait(),Thread.join()和LockSupport.park(Object)可以使得线程变为Waiting状态，而执行Object.notify()/notifyAll()和LockSupport.unpark()可以使线程从Waiting变更为Runnable.
     (5) Timed_Waiting:该状态和Waiting类似，差别在于不会无节制的等待期待线程执行特定操作，带有时间的限制，时间一到自动转换为Runnable.
     (6) Terminated:已经执行结束的线程处于该状态。
   
   线程的竞态：
     导致竞态的常见因素是多个线程在没有采取措施的情况下并发的读取更新一个共享变量（类变量）
     两种模式：
        读-改-写 ； 检查而后行动
        
   
   原子性：
      对于涉及共享变量的操作，若该操作从除本身外其他线程看是不可分割的，那么该操作就是原子操作，具有原子性，描述的是一个线程对共享变量的更新，从另外一个线程的角度看，它要么完成，要么尚未发生
      实现原子性：
         （1）使用锁
          (2)利用处理器的CAS指令
      long和double以外的基本类型的写操作都是原子操作
    
    
    可见性：
        指一个线程对共享变量的更新的结果对于读取相应共享变量的其他线程而言是否可见的问题
        可使用volatile保证可见性
        父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的，但是在子线程启动之后对共享变量的更改的可见性是没有保证的
        一个线程终止后对共享变量的更新，对于调用该线程的join方法的线程而言是可见的
        
        
    有序性：
        重排序可能导致线程安全问题，但不是必然发生的
        
        
    上下文切换：
        可以看成是多个线程共享一个处理器的产物
        一个线程被暂停，剥夺CPU的使用权，另外一个线程被选中开始或者继续执行的过程叫做上下文切换
        可分为：自发性上下文切换和飞自发性上下文切换
            自发性上下文切换由于其自身因素导致的切出。导致自发性上下文切换：
                （1）Thread.sleep()
                 (2)Object.wait()/wait(long timeout)/wait(long timeout,int nanos)
                 (3)Thread.yield()
                 (4)Thread.join()/Thread.join(long timeout)
                 (5)LockSupport.part()
                 阻塞式I/O操作或者等待其他线程持有的锁
             非自发性上下文切换指由于线程调度器的原因被迫切出。导致：
                   (1)线程的时间片用玩
                   (2)有优先级更高的线程需要运行
         由于上下文切换的开销，有时候多线程编程不一定比单线程编程的计算效率更高
         
         
      线程的活性故障
        （1）死锁
        （2）锁死
        （3）活锁：线程处于Runnable状态，但是想要执行的任务毫无进展，一直做无用功
        （4）饥饿
        
      资源的争用与调度
           争用：在一个线程占用一个排他性的资源进行访问，而未释放其对资源所有权的时候，其他线程视图访问该资源的线像就称为争用
           资源调度一个常见的策略是排队。资源调度器内部维护一个等待的队列，在存在资源争用的情况下，申请失败的资源申请者(线程)会被存入该队列，存入队列的线程通常会被暂停，等待被唤醒。
           
   
      内部锁的调度（synchronized）：
           java虚拟机会为每一个内部锁分配一个入口集Entry Set，用于记录等待锁获得相应内部锁的线程，多个线程申请一个内部锁时，未获得锁的线程会被暂停（生命周期状态为Blocked）放进入口集中，当锁空闲时，虚拟机会唤醒其中的一个，但由于内部锁不是公平锁，因此被唤醒的锁需要与从未进去入口集的锁进行竞争。
           
           
      显式锁的调度（Lock）:
           ReentrantLock既支持公平锁，也支持不公平锁，默认为不公平锁，公平锁的开销大
           构造器ReentrantLock(boolean fair)fair的值为ture时是公平锁。
           
         
       读写锁（ReadWriteLock）：
           读锁（readLock）是共享的，写锁(writeLock)排他的
           
           
       锁优化：
            自旋锁与自适应锁
            锁消除
            锁粗化
            轻量级锁
            偏向锁
