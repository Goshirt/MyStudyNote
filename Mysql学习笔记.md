# Mysql数据类型

* 整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间
* 浮点数：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。
    > CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。        
* 字符串：CHAR 和 VARCHAR，一种是定长的，一种是变长的
     > VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。        
* 时间和日期：DATATIME 和 TIMESTAMP
     > DATATIME ：能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关
       TIMESTAMP：和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，
                  只能表示从 1970 年 到 2038 年，它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的
       MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳
# 数据库ACID：
* 原子性（Atomicity）
     > 原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
* 一致性（Consistency）
     > 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是100，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是100，这个就是事务的一致性。
* 隔离性（Isolation）
     > 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
* 持久性（Durability）
    > 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复          
# 并发可能产生的问题：

* 丢失修改：
   > T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改
          
* 脏数据读取：（解决办法：事务隔离级别改为 READ_COMMITTED）
    > 如果一个事务中对数据进行了更新，但事务还没有提交，另一个事务可以 “看到” 该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚,那么，第二个事务在此之前所 “看到” 的数据就是一笔脏数据。 （脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 ）应用示例：
      Jame的原工资为 1000, 财务人员将Jame的工资改为了 8000 (但未提交事务)Jame读取自己的工资，发现自己的工资变为了 8000，欢天喜地！而财务发现操作有误，回滚了事务，Jame的工资又变为了1000像这样的事件，Jame记取的工资数8000就是一个脏数据
                  
* 不可重复读：（解决办法：事务隔离级别改为 REPEATABLE_READ）
    > 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（同时操作，事务1分别读取事务2操作时和提交后的数据，读取的记录内容不一致。不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。 ）应用示例：
    在事务1中，Jame读取了自己的工资为1000，操作并没有完成
        con1 = getConnection();  
        select salary from employee empId ="Mary"; 
        #在事务2中，这时财务人员修改了Jame的工资为 2000，并提交了事务.
        con2 = getConnection();  
        update employee set salary = 2000;  
        con2.commit();  
        #在事务1中，Jame再次读取自己的工资时，工资变为了2000
        #con1  
        select salary from employee empId ="Mary";  
                
 * 幻读：（解决办法：事务隔离级别改为 SERIALIZABLE_READ）
    > 事务 T1 读取一条指定的 Where 子句所返回的结果集，然后 T2 事务新插入一行记录，这行记录恰好可以满足T1 所使用的查询条件。然后 T1 再次对表进行检索，但又看到了 T2 插入的数据。 （和可重复读类似，但是事务 T2 的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致）.幻读的重点在于新增或者删除 (数据条数变化).同样的条件，第1次和第2次读出来的记录数不一样.应用示例:
    目前工资为1000的员工有10人
        #事务1，读取所有工资为 1000 的员工（共读取 10 条记录 ）
        con1 = getConnection();  
        Select * from employee where salary =1000;  
        #这时另一个事务向 employee 表插入了一条员工记录，工资也为 1000
        con2 = getConnection();  
        Insert into employee(empId,salary) values("Lili",1000);  
        con2.commit();  
        #事务1再次读取所有工资为 1000的 员工（共读取到了 11 条记录，这就像产生了幻读）
        #con1  
        select * from employee where salary =1000; 
                
## 事务隔离级别：
 * 串行化 (Serializable)：
   > 所有事务一个接着一个的执行，这样可以避免幻读 (phantom read)，对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务   
 * 可重复读 (Repeated Read)：
   > 所有被 Select 获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，即前一个事务有读锁但是没有范围锁，为什么叫做可重复读等级呢？那是因为该等级解决了下面的不可重复读问题    
 * 读已提交 (Read Committed)：
   > 被读取的数据可以被其他事务修改，这样可能导致不可重复读。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。该等级也是 SQL Server 默认的隔离等级。   
 * 读未提交 (Read Uncommitted)：
   > 最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读。
              
## 锁粒度：  
  * 行级锁和表级锁
      > 应该尽量只锁定需要修改的部分数据，而不是所有资源，锁定的数据量越少，发生锁争用的可能就越小，并发程度越高。加锁需要消耗资源，锁的各种操作会增加系统开销，因此封锁的粒度越小，系统开销越大，需要在开销和并发程度之间做一个权衡
        
## 封锁类型：
* 共享锁：
  > 也叫S锁，是一种读锁，当一个事务获得了一条数据的共享锁，其他事务也可以获得该共享锁，但不能获得排他锁，表示其他事务可读，但不可写。
* 排他锁：
  > 也叫X锁，是一种写锁，当一个事务对临界区加上排他锁，其他事务不能获得该临界区的任何锁（包括共享过和排他锁）表示只能一个人去处理数据,其他人不能读也不能写。               
* 意向锁：
  > 意向锁可以更容易地支持多粒度封锁；存在行级锁和表级锁的情况下，事务T想对表A加排他锁，需要先检测是否有其他事务对表A或者表A 的任意一行加了锁，那么需要对表A的每一行都检测一次，非常耗时；意向锁在原来的X/S锁上引入了IX/IS锁，都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。有以下两个规定：
      一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁；
      一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁                 
* 观锁：
  > 锁假设认为数据一般情况下不会造成冲突，所以只会对数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突了，则返回用户错误的信息，让用户决定如何去做。实现乐观锁的两种方式：
 1.用版本号，为数据增加一个版本标识，读数据时，将version一同读出，数据每更新一次对version加一，当提交更新时，判断数据表对应记录的版本信息与第一次读取出来的version值比对，如果相等，则予以更新，否则，认为是过期数据；
  2.间戳：增加一个字段，使用时间戳，更新提交时检查当前数据库中数据的时间戳和自己更新前取到的时间戳对比，如果一致则OK，否则就是版本冲突。使用时间戳：增加一个字段，使用时间戳，更新提交时检查当前数据库中数据的时间戳和自己更新前取到的时间戳对比，如果一致则OK，否则就是版本冲突。
* 观锁：
  > 是是对数据被外界（本系统的其他事务，来自外部系统的事务处理）修改持保守的态度。在整个数据处理中，将数据处于锁定的状态；悲观锁的实现，要依靠数据库提供的锁机制                    
## 储引擎
 MySQL 5.5 以前的默认存储引擎是 MyISAM, MySQL 5.5 之后的默认存储引擎是 InnoDB
   1. MyISAM：在 5.0 以前最大表存储空间最大 4G，5.0 以后最大 256TBMyisam 存储引擎由 .myd（数据）和 .myi（索引文件）组成，.frm文件存储表结构（所有存储引擎都有）特性：
     * 并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥）
     *　表损坏修复
     * Myisam 表支持的索引类型（全文索引）
     * Myisam 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩）
   2. InnoDB:MySQL 5.5 及之后版本的默认存储引擎特性
     * InnoDB为事务性存储引擎
     * 完全支持事物的 ACID 特性
     * Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚）
     * InnoDB支持行级锁
     * 行级锁可以最大程度的支持并发
     * 行级锁是由存储引擎层实现的
   3. CSV:文件系统存储特点
     * 数据以文本方式存储在文件中
     * .csv文件存储表内容
     * .csm文件存储表的元数据，如表状态和数据量
     * .frm存储表的结构
   4. CSV存储引擎特点
     * 以 CSV 格式进行数据存储
     * 所有列必须都是不能为 NULL
     * 不支持索引
     * 可以对数据文件直接编辑（其他引擎是二进制存储，不可编辑）
   5. Archive:特性
     * 以 zlib 对表数据进行压缩，磁盘 I/O 更少
     * 数据存储在ARZ为后缀的文件中（表文件为 a.arz，a.frm）
     * 只支持 insert 和 select 操作（不可以 delete 和 update，会提示没有这个功能）
     * 只允许在自增ID列上加索引
   6. Memory也称为 HEAP 存储引擎，所以数据保存在内存中（数据库重启后会导致数据丢失）支持 HASH 索引（等值查找应选择 HASH）和 BTree 索引（范围查找应选择）所有字段都为固定长度，varchar(10) == char(10)不支持 BLOG 和 TEXT 等大字段Memory 存储使用表级锁（性能可能不如 innodb）最大大小由 max_heap_table_size 参数决定Memory存储引擎默认表大小只有 16M，可以通过调整 max_heap_table_size 参数
   7. Federated:
    * 提供了访问远程 MySQL 服务器上表的方法
    * 本地不存储数据，数据全部放在远程服务器上
   存储引擎的选择：首选Innodb 
       
## MyISAM和InnoDB引擎的区别?
* MyISAM 不支持外键，而 InnoDB 支持
* MyISAM 是非事务安全型的，而 InnoDB 是事务安全型的。
* MyISAM 锁的粒度是表级，而 InnoDB 支持行级锁定。
* MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引。
* MyISAM 相对简单，所以在效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM。
* MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。
* InnoDB 表比 MyISAM 表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。
应用场景：
  > MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT 或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能
              
   # MySQL的索引：
    
       特性	              说明	                  InnoDB	MyISAM	MEMORY

      B树索引            自增ID物理连续性更高，
                         二叉树，红黑树高度不可控	      √	       √	      √

      R树索引              	空间索引		                       √	

      哈希索引             无法做范围查询	             √		             √

      全文索引 		                                     √	      √



       使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组 B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找
    哈希索引: InnoDB 引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找无法用于排序与分组；只支持精确查找，无法用于部分查找和范围查找
    全文索引:yISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE
                  
## 索引的特点
   * 以加快数据库的检索速度
   * 低数据库插入、修改、删除等维护的速度
   * 能创建在表上，不能创建到视图上
   * 可以直接创建又可以间接创建
   * 可以在优化隐藏中使用索引
   * 使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引
              
## 索引的优点:
   * 可以创建唯一性索引，保证数据库表中每一行数据的唯一性
   * 大大加快数据的检索速度，这是创建索引的最主要的原因
   * 加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义
   * 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
   * 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能
            
## 索引的缺点:
   * 可以创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
   * 索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大
   * 当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度

