流程控制学习：
      打开 command window,切换到Editor模式，复制代码到dialog中，并添加一个/,enter看到执行结果
      
      
      1.
      set serverout on; //为了可以在dialog中看到输出结果
      begin
        dbms_output.put_line('hello');
       end;
       
       
       2.
      set serverout on;
      declare n number :=1;
      begin
        dbms_output.put_line('hello'|| n);
       end;
       
       
       3.
      set serverout on;
      set serverout on;
      declare n number :=1;
              name varchar2(20) :='word';
      begin
        dbms_output.put_line('hello'|| n || name);
       end;
       
       
       4.简单的if-else查询
       set serverout on;
       declare emp_count number;
       begin
         select count(*) into emp_count from EMP where sal >=3000;
         if emp_count > 0 then
           dbms_output.put_line('有员工' || emp_count || '工资大于3000');
          else
            dbms_output.put_line('没有员工工资大于3000');
           end if;
       end;
       
       
       5.多个else if 查询，当有多少个if 出现，就得end if多少个匹对
       set serverout on;
       declare emp_count number;
       begin
         select count(*) into emp_count from EMP where sal >=3000;
         if emp_count =1 then
           dbms_output.put_line('有员工1个，工资大于3000');
         else if emp_count > 1 then
           dbms_output.put_line('有多于1个员工，工资大于3000');
         else
            dbms_output.put_line('没有员工工资大于3000');
         end if;
         end if;
       end;
       
       
       6.case 使用
       set serverout on;
       declare emp_count number;
       begin
         select count(*) into emp_count from EMP where sal >=3000;
         case emp_count
           when 0 then dbms_output.put_line('没有员工工资大于3000');
           when 1 then dbms_output.put_line('有员工1个，工资大于3000');
           when 2 then dbms_output.put_line('有员工2个，工资大于3000');
           when 3 then dbms_output.put_line('有员工3个，工资大于3000');
           when 4 then dbms_output.put_line('有员工大于3个，工资大于3000');
          end case;
        end;


      7.loop的使用
        set serverout on;
        declare g_id number :=1;
                g_losal number;
                g_hisal number;
         begin
           loop
             if(g_id>4) then
                 exit;
              end if;
              select losal,hisal into g_losal,g_hisal from salgrade where grade=g_id;
              dbms_output.put_line(g_id || '等级的最低薪资' || g_losal || '最高工资' || g_hisal);
              g_id := g_id+1;
            end loop;
          end;
          
      8.while的使用
        set serverout on;
        declare g_id number :=1;
                g_losal number;
                g_hisal number;
         begin
            while g_id<5 loop
              select losal,hisal into g_losal,g_hisal from salgrade where grade=g_id;
              dbms_output.put_line(g_id || '等级的最低薪资' || g_losal || '最高工资' || g_hisal);
              g_id := g_id+1;
            end loop;
          end;
          
       9.for 的使用
        set serverout on;
        declare g_id number :=1;
                g_losal number;
                g_hisal number;
         begin
            for g_id in 2..4 loop
              select losal,hisal into g_losal,g_hisal from salgrade where grade=g_id;
              dbms_output.put_line(g_id || '等级的最低薪资' || g_losal || '最高工资' || g_hisal);
            end loop;
          end;
          
          
       10.简单的游标的使用
         set serverout on;
          declare cursor cu_emp is
                  select empno,ename,sal from emp;
            e_no number;
            e_name varchar2(10);
            e_sal number;
          begin
            open cu_emp;
            fetch cu_emp into e_no,e_name,e_sal;
            while cu_emp%found loop
                  dbms_output.put_line('编号'|| e_no || '姓名'|| e_name ||'基本薪资'|| e_sal);
                  fetch cu_emp into e_no,e_name,e_sal;
                end loop;
              close cu_emp;
          end;
          
        11.使用 tableName.attr%type 动态的指定变量的类型与表字段的类型一样
        set serverout on;
          declare cursor cu_emp is
                  select empno,ename,sal from emp;
            e_no emp.empno%type;
            e_name emp.ename%type;
            e_sal emp.sal%type;
          begin
            open cu_emp;
            fetch cu_emp into e_no,e_name,e_sal;
            while cu_emp%found loop
                  dbms_output.put_line('编号'|| e_no || '姓名'|| e_name ||'基本薪资'|| e_sal);
                  fetch cu_emp into e_no,e_name,e_sal;
                end loop;
              close cu_emp;
          end;
          
          
          12.使用 tabkeName%rowtype 动态的指定一个变量，并且该变量为表所有的字段的类型，相当于row,减少变量的定义
          set serverout on;
          declare cursor cu_emp is
                  select * from emp;
           e_row emp%rowtype;  
          begin
            open cu_emp;
            fetch cu_emp into e_row;
            while cu_emp%found loop
                  dbms_output.put_line('编号'|| e_row.empno || '姓名'|| e_row.ename ||'基本薪资'|| e_row.sal);
                  fetch cu_emp into e_row;
                end loop;
              close cu_emp;
          end;
          
          13.隐式游标的使用  sql%isopen boolean值，隐式游标打开为true 默认关闭
           set serverout on;
          begin
            if sql%isopen then
              dbms_output.put_line('游标打开');
             else
               dbms_output.put_line('游标关闭');
              end if;
            end;
            
          14.动态游标的使用  type  is ref cursor return emp%rowtype; 定义一个类型为游标并且指定游标的返回数据的类
           set serverout on;
            declare type emptype is ref cursor return emp%rowtype;  //指定了该游标只能是表emp的行类型
            cu_emp emptype; // 定义这个类的一个变量
            e_count number;
            e emp%rowtype;
            begin
              select count(*) into e_count from emp where job='PRESIDENT';
              if e_count > 0 then  //如果大于0，cu_emp就是返回表的都有数据
                open cu_emp for select * from emp;  //
              else   //没有那个人，cu_emp返回的就是符合条件的数据
                open cu_emp for select * from emp where job='PRESIDENT';
               end if;
               fetch cu_emp into e;
                     while cu_emp%found loop
                       dbms_output.put_line('编号'|| e.empno || '姓名'|| e.ename ||'基本薪资'|| e.sal);
                       fetch cu_emp into e;
                       end loop;
                  close cu_emp;
              end;
              
           15.动态游标的弱类型 不指定游标的数据类型，根据业务指定
           set serverout on;
            declare type customType is ref cursor;
               e_count number;
               e emp%rowtype;
               s salgrade%rowtype;
               cType customType;
               begin
                 select count(*) into e_count from emp where job='PRESIDENT';
                 if e_count > 0 then
                   open cType for select * from salgrade;
                       fetch cType into s;
                          while cType%found loop
                           dbms_output.put_line(s.grade || '等级的最低薪资' || s.losal || '最高工资' || s.hisal); 
                            fetch cType into s;
                            end loop;
                           close cType;
                  else
                    open cType for select * from emp;
                      fetch cType into e;
                          while cType%found loop
                           dbms_output.put_line('编号'|| e.empno || '姓名'|| e.ename ||'基本薪资'|| e.sal);
                            fetch cType into e;
                            end loop;
                           close cType;
                    end if;

                 end;


               16.函数的基本用法
               create function getBookCount return number as
                  begin
                    declare book_count number;
                    begin
                      select count(*) into book_count from t_book;
                      return book_count;
                    end;
                  end getBookCount;
                  
               17.带参数的函数的基本用法
               create function getTableCount(table_name varchar2) return number as
                  begin
                    declare recore_count number;
                    query_sql varchar2(300);
                    begin
                      query_sql:='select count(*) from ' || table_name;  //将用户传递进的表名拼接
                      execute immediate query_sql into recore_count;  //执行语句并将结果赋给recore_count
                      return recore_count;
                    end;
                  end getTableCount;
                  
               18.存储过程的基本用法 
               create procedure addBook(bookName in varchar2,typeId in number) as
                  begin
                    declare maxId number;
                    begin
                      select max(id) into maxId from t_book;
                      insert into t_book values(maxId+1,bookName,typeId);
                      commit;
                    end;
                  end addBook;
               
               19.带判断的存储过程的基本用法 
               create procedure addBook2(bN in varchar2,typeId in number) as
                  begin
                    declare maxId number;
                    n number;
                    begin
                      select count(*) into n from t_book where bookName=bN;
                      if(n>0) then  //如果指定的bookName存在，就返回
                       return;
                      end if;  //不存在就插入
                      select max(id) into maxId from t_book;
                      insert into t_book values(maxId+1,bN,typeId);
                      commit;
                    end;
                  end addBook2;
                  
                20.带输入输出参数的存储过程的基本用法
               create procedure addBook3(bN in varchar2,typeId in number,n1 out number,n2 out number) as
                  begin
                    declare maxId number;
                    n number;
                    begin
                      select count(*) into n1 from t_book;
                      select count(*) into n from t_book where bookName=bN;
                      if(n>0) then
                       return;
                      end if;
                      select max(id) into maxId from t_book;
                      insert into t_book values(maxId+1,bN,typeId);
                      select count(*) into n2 from t_book;
                      commit;
                    end;
                  end addBook3;
               
