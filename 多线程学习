   线程的状态
    （1）new：一个创建而未启动的线程处于该状态
    （2）Runable:包含两个子状态Ready和Running,前者表示处于该状态下的线程可以被线程调度器进行调度，后者表示线程正在运行。Ready状态被线程调度器调度后变成Running状态，执行Thread.yield(),有可能导致Running状态转换为Ready状态。
     (3) Blocked:当一个线程发起一个阻塞IO操作，或者申请一个其他线程持有的独占资源时，处于该状态。在该状态下不占用CPU资源，当阻塞IO操作完成后，或者获得了其申请的资源，该线程状态可以转换为Runnable.
     (4) Waiting:一个线程执行某些特定方法之后会处于这种等待其他线程执行另外的特定操作。Object.wait(),Thread.join()和LockSupport.park(Object)可以使得线程变为Waiting状态，而执行Object.notify()/notifyAll()和LockSupport.unpark()可以使线程从Waiting变更为Runnable.
     (5) Timed_Waiting:该状态和Waiting类似，差别在于不会无节制的等待期待线程执行特定操作，带有时间的限制，时间一到自动转换为Runnable.
     (6) Terminated:已经执行结束的线程处于该状态。
   
   线程的竞态：
     导致竞态的常见因素是多个线程在没有采取措施的情况下并发的读取更新一个共享变量（类变量）
     两种模式：
        读-改-写 ； 检查而后行动
        
   
   原子性：
      对于涉及共享变量的操作，若该操作从除本身外其他线程看是不可分割的，那么该操作就是原子操作，具有原子性，描述的是一个线程对共享变量的更新，从另外一个线程的角度看，它要么完成，要么尚未发生
      实现原子性：
         （1）使用锁
          (2)利用处理器的CAS指令
      long和double以外的基本类型的写操作都是原子操作
    
    
    可见性：
        指一个线程对共享变量的更新的结果对于读取相应共享变量的其他线程而言是否可见的问题
        可使用volatile保证可见性
        父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的，但是在子线程启动之后对共享变量的更改的可见性是没有保证的
        一个线程终止后对共享变量的更新，对于调用该线程的join方法的线程而言是可见的
        
        
    有序性：
        重排序可能导致线程安全问题，但不是必然发生的
        
        
    上下文切换：
        可以看成是多个线程共享一个处理器的产物
        一个线程被暂停，剥夺CPU的使用权，另外一个线程被选中开始或者继续执行的过程叫做上下文切换
        可分为：自发性上下文切换和飞自发性上下文切换
            自发性上下文切换由于其自身因素导致的切出。导致自发性上下文切换：
                （1）Thread.sleep()
                 (2)Object.wait()/wait(long timeout)/wait(long timeout,int nanos)
                 (3)Thread.yield()
                 (4)Thread.join()/Thread.join(long timeout)
                 (5)LockSupport.part()
                 阻塞式I/O操作或者等待其他线程持有的锁
             非自发性上下文切换指由于线程调度器的原因被迫切出。导致：
                   (1)线程的时间片用玩
                   (2)有优先级更高的线程需要运行
         由于上下文切换的开销，有时候多线程编程不一定比单线程编程的计算效率更高
         
         
      线程的活性故障
        （1）死锁
        （2）锁死
        （3）活锁：线程处于Runnable状态，但是想要执行的任务毫无进展，一直做无用功
        （4）饥饿
        
      资源的争用与调度
           争用：在一个线程占用一个排他性的资源进行访问，而未释放其对资源所有权的时候，其他线程视图访问该资源的线像就称为争用
           资源调度一个常见的策略是排队。资源调度器内部维护一个等待的队列，在存在资源争用的情况下，申请失败的资源申请者(线程)会被存入该队列，存入队列的线程通常会被暂停，等待被唤醒。
           
   
      内部锁的调度（synchronized）：
           java虚拟机会为每一个内部锁分配一个入口集Entry Set，用于记录等待锁获得相应内部锁的线程，多个线程申请一个内部锁时，未获得锁的线程会被暂停（生命周期状态为Blocked）放进入口集中，当锁空闲时，虚拟机会唤醒其中的一个，但由于内部锁不是公平锁，因此被唤醒的锁需要与从未进去入口集的锁进行竞争。
           
           
      显式锁的调度（Lock）:
           ReentrantLock既支持公平锁，也支持不公平锁，默认为不公平锁，公平锁的开销大
           构造器ReentrantLock(boolean fair)fair的值为ture时是公平锁。
           
         
       读写锁（ReadWriteLock）：
           读锁（readLock）是共享的，写锁(writeLock)排他的
