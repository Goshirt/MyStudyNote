容器：
  （1）Collection
        List:按照插入顺序保存的一组元素
            ArrayList:随机访问快，插入和移出慢
            LinkedList:随机访问慢，插入移出快,可以实现栈的所有功能
        Set:不能有重复的元素,对快速查找进行了优化
            HashSet:散列表
            TreeSet:存储在红黑树数据结构中，可以在构造函数中传递一个Comparator<T>进行排序
            LinkedHashList:散列表，并且使用链表维护元素的插入顺序
        Queue:按照排队规则来确定对象的产生顺序，先进先出
            LinkedBlockingQueue的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，
                不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。
            ArrayBlockingQueue在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，
                等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。
                通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序
            PriorityBlockingQueue是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，
                该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是
                没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，
                所以试图执行添加操作可能会导致 OutOfMemoryError），
                但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。
             DelayQueue（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。
                该队列的头部是延迟期满后保存时间最长的 Delayed 元素。
                如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，
                则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。
   (2) Map
   
   
 迭代器Iterrator：
    （1）使用方法iterator()要求容器返回一个Iterator.Iterator将准备好返回序列的第一个元素
    （2）使用next()获得序列中是否还有元素
    （3）使用hasNext（）检查序列中是否还有元素
    （4）使用remove()将迭代器新返回的元素删除
    
 ListIterator:一个更加强大的Iterator的子类型，只能用于各种List类的访问，并且可以双向移动
     listIterator()产生一个指向List开始处的ListIterator
     listIterator(n)产生一个指向索引为n的元素处的ListIterator




常见问题：
    HashSet如何保证不重复
      底层源码：HashSet的add方法（map是一个ransient类型的HashMap<E,Object>）：
          public boolean add(E e) {
            return map.put(e, PRESENT)==null;
          }
       而HashMap的put方法：
          public V put(K key, V value) { 
            if (key == null) return putForNullKey(value); 
            int hash = hash(key.hashCode()); 
            int i = indexFor(hash, table.length); 
            for (Entry<K,V> e = table[i]; e != null; e = e.next) { 
                Object k; 
                if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                    V oldValue = e.value; e.value = value; 
                    e.recordAccess(this); return oldValue; 
                 } 
             } 
             modCount++; addEntry(hash, key, value, i); return null; 
         }
        通过put方法的for循环可以看到是遍历整个表，然后通过hash值以及equals（）判断新添加的元素是否已经存在
        如果hash码值相同，且equles判断相等，说明元素已经存在，不存
        如果hash码值相同，且equles判断不相等，说明元素不存在，存
        
        
        
        TreeSet怎么保证数据的顺序
          当使用TreeSet的add方法是，add()的元素必须实现了Comparable接口，否则会报错
          因为保证数据的顺序是通过Comparable实现的
          例如添加persion实体
          public class Person implements Comparable<Person> {
              private String name;
              private int age;
              ...
              public int compareTo(Person o) {
                  return 0;                //当compareTo方法返回0的时候集合中只有一个元素
                  return 1;                //当compareTo方法返回正数的时候集合会怎么存就怎么取
                  return -1;                //当compareTo方法返回负数的时候集合会倒序存储
              }
          }
          为什么返回0，只会存一个元素，返回-1会倒序存储，返回1会怎么存就怎么取呢？原因在于TreeSet底层其实是一个二叉树机构，且每插入一个新元素(第一个除外)都会调用```compareTo()```方法去和上一个插入的元素作比较，并按二叉树的结构进行排列。
            1. 如果将```compareTo()```返回值写死为0，元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。所以TreeSet中就只存在插入的第一个元素。
            2. 如果将```compareTo()```返回值写死为1，元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。
            3. 如果将```compareTo()```返回值写死为-1，元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。
        
     
